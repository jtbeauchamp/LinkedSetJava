# LinkedSetJava
This project is about implementing a set data structure with the use of a node class. It utilizes methods within the linked set that allows for manipulation and retrieval of the data inside.

Section 1: Project Specification
	The data type I chose for this project was a linked set. A linked list is an abstract data type (ADT), which is a specification of a data set and the operations on that set, However, the way the data is stored or how to implement the operations is not indicated by the specification. The specification is independent of any programming language. The linked set implements an array, which stores nodes. These nodes all reference each other and create a “link.” It is a linear data structure since an array is being used. I chose an array since we are storing string objects in a way that can avoid moving data when adding or removing data by utilizing nodes and the “chain” they make. And because of this, an array allows for removal and addition of objects via retrieving their data portions in a node that references it, which is similar to indexes. However, a linked set does not allow for duplicates. Therefore, methods that would typically be in an array bag, such as getFrequencyOf, are not included since there is no need for such methods. Moreover, this linked set is more dynamic than an array bag would be. Instead of having a set amount in terms of the entries it can store, a linked set simply adds a node to the end to form a chain that does not require a set size. This saves the trouble of doubling an array, and removes and recycles nodes that are not needed. In terms of functionality, the linked set can add entries to the chain either at the beginning or end of the chain with ease, which is similar for the remove methods. To construct the linked set, I had to specify its data and the methods the set will implement. I had to define private variables, such as “numberOfEntries” that holds the number of entries in the set, and “firstNode,” which references the firstNode in the chain. In addition, I had to define a private inner class for Node. In this class, it had a private generic variable “data” that held the entry in each node, and a private Node variable “next” which referenced the next node on the chain. Inside the class were two constructors, a default and parameterized constructor. The default constructor only created a Node that had “data” and no “next.” The parameterized constructor creates a node that has “data” and a “next” to reference. By using private helper methods and public interfaces, the linked set is able to create the so-called “chain” of nodes that can store linear data utilizing an array.
 
Section 2: Testing Methodology
	To test my ADT, I ran a test of five different cases, all respectively called “Case 1” to “Case 5” for the three new interfaces, which were “equals,” “union,” and “toString.” The method union would take two sets and create a new linked set that combined all the entries from both sets, making sure to avoid duplicates in the process. The next method was “equals” which took two sets and compared sizes and entries, returning true if the sets were equal in every aspect, or else false. Finally, the last method was a “toString” method for the linked sets only that would output them within brackets, separating each entry with commas. Moving on to the testing, each test had two sets called “Set A” and “Set B,” and any methods that created a new set would result in the creation of “Set C.” For case 1, the sets were equal, but distinct. Set A consisted of {1,2,3} and Set B consisted of {2,1,3}. The “equals” method called on Set A using Set B as its parameter resulted in a return value of true. More so, the “union” method was called on Set A with Set B as its parameter, and using the “toString” method to output Set C, the output resulted in {3,2,1}. Moving on to case 2, the sets were of different sizes, but one is a subset of the other. Set A consisted of {1} and Set B consisted of {1,2}. The “equals” method used on Set A with Set B as its parameter resulted in a return value of false. The “union” method was called on Set A with Set B as its parameter, and using the “toString” method to output Set C, the output resulted in {2,1}. Next, case 3 had sets that were non-empty, but had common elements. Set A consisted of {1,2,3} and Set B consisted of {2,3,4,5}. The “equals” method called on Set A using Set B as its parameter resulted in a return value of false. The “union” method was called on Set A with Set B as its parameter, and using the “toString” method to output Set C, the output resulted in {5,4,3,2,1}. More so, for case 4 the sets were non-empty with nothing in common. Set A was composed of {1} and Set B was {2,3}. The “equals” method called on Set A using Set B as its parameter resulted in a return value of false. The “union” method was called on Set A with Set B as its parameter, and using the “toString” method to output Set C, the output resulted in {2,3,1}. Finally, for case 5, the sets are non-empty with the other empty. Set A consisted of {} and Set B consisted of {1,2}. The “equals” method called on Set A with Set B as its parameter resulted in false. Moreover, the “union” method on Set A using Set B  resulted in Set C being {2,1}. These five tests completely demonstrate that the methods are functioning as intended because any possible combination for the two sets have been checked and the results have shown that each of the methods passes the tests. Moreover, the sets are cleared after every test, making sure that there is no room for any sets to be different from the ones that were explained to be tested, and I made sure by outputting Set A and Set B with the “toString” method each time. Therefore, the test displays the accuracy and functionality of each of the three methods, completely checking each one to make sure there are no errors in their outputs. Now that the special cases have been tested for the three special methods, the rest of the testing was for the core methods. I used words as the string parameters for the following tests and only used the methods on Set A since the tests only allowed for one set to be tested. The first test was for the “add” method, which does not allow for duplication. The linked set is first cleared to remove any remains from case 5. Then, a for loop calls to add the string “a” to the set five times. After, the “getCurrentSize” method is called onto the set, and shows the size is only one entry, demonstrating that the add method was functioning as intended. This test shows how proficient the “add” method is by adding the same string into the set five times, only to display that only one of the strings was allowed to be added in the set. Next, the “toArray” method was tested. First, we clear the set from the previous test. Then, we add “Hi,” “how,” “are,” “you” into the set. From there, we transfer the set’s entries into an array using the method. The program calls for a for loop to output all the items one by one to show that the words have successfully been transferred to a newly made array. The test shows that method is complete without any errors by using a for loop that uses the array’s length as a parameter to show that all the entries are accounted for, then it outputs the words one by one on a new line. Therefore, if there was an error anywhere, the output would not match up with the set that was originally made for this method’s test. In addition, the next test was for the “contains” method. The program checks to see if the string “Joshua” is in the set. Since the string was never added, the result from the “contains” method output was false. As a result, I call for the string “Joshua” to be added to the set, which when running the “contains” method after results in true. By adding a string that is unique to the previous entries, we are able to see how the method is working properly without any error. The next methods tested are both the non-parameterized “remove” method and the parameterized version of “remove.” Starting with the parameterized remove, I add the string “Howdy” to the set. Then, I add the letters “b” to “d” to the set to make sure that the set does not just remove the last entry with the parameterized remove method and not the entry that it is supposed to. By running the “contains” method after adding the strings, the output returns true that the set does contain the string “howdy.” Therefore, we run the “remove” method with the given parameter of the string “Howdy,” and then by running the “contains” method for “Howdy” the result comes back as false. This shows that the remove method is functioning and intended and the test proves so by adding more strings after the string “Howdy” to check that it does remove the entry that it needs to. Moreover, the test for the non-parameterized “remove” method is quite simple. All the program does is run the “getCurrentSize” method to return the number 8, then run the non-parameterized “remove” method. After running “remove,” the number returned from running the “getCurrentSize” method another time is 7, which indicates the method is working as intended. The test shows that the method is working as intended since it is a basic operation and shows that the size does in fact decrease and an entry is removed from the chain. Finally, the last methods tested are “clear” and “getCurrentSize.” Although “getCurrentSize” is used in other methods’ testing, I still wanted to intentionally test its functionality as well. Therefore, since the set’s size is still 7, which is proven by running the “getCurrentSize” another time before the testing, I run the “clear” method. After running “clear,” I run “getCurrentSize” a last time to return a value of 0. Since the testing shows positive results and tests the non-complex coding of the two methods, it is safe to say that the test thoroughly checks the two methods by clearing the set of a large number of entries and retrieving the size for the set before and after it is cleared.
